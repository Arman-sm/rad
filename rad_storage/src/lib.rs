// This crate is dedicated to managing, storing, and caching audio segments generated by different sources.
// 
// The idea is that each source can optionally offload the management of these audio segments to the global segment store,
// where it can stay loaded in memory until it is not actively used and then can either be deleted or saved to disk
// in case the audio is only able to be generated once or is expensive to generate.
//
// With the following tasks managed by one single module it is hoped that the memory can be used more efficiently and in a lower quantity.

use std::sync::{Arc, LazyLock, RwLock};

pub mod segment_store;

pub mod macros {
    #[macro_export]
    macro_rules! respond_storage {
        ($pile_id:expr, $frame_idx:expr) => {
            {
                let mut lk = GLOBAL_SEGMENT_STORE.write().unwrap();
                let _seg = lk.find($pile_id, $ frame_idx);
                if let Some(seg) = _seg {
                    return Some(seg.data.fetch()[(($frame_idx - seg.frame_idx) * seg.channels as u64) as usize..(($frame_idx - seg.frame_idx + 1) * seg.channels as u64) as usize].to_vec());
                }
            }
        };
    }
}

pub static GLOBAL_SEGMENT_STORE: LazyLock<Arc<RwLock<segment_store::SegmentStore>>> =
    LazyLock::new(segment_store::SegmentStore::new);